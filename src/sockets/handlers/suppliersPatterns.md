# Архитектура и Паттерны Проекта Pricer-Back-TS

Этот документ описывает архитектурные решения и ключевые паттерны проектирования, использованные в бэкенде. Понимание этих принципов критически важно для поддержки и дальнейшего развития проекта.

## 1. Общая философия

Изначально проект имел структуру, где логика для каждого поставщика была разрознена, что приводило к значительному дублированию кода. Ключевой целью рефакторинга было **централизовать общую логику и изолировать уникальную** , сделав систему более гибкой, читаемой и легко расширяемой.

Мы достигли этого, применив комбинацию нескольких классических паттернов проектирования в функциональном стиле, что идеально подходит для TypeScript/Node.js.

## 2. Ключевые паттерны проектирования

В основе нашей системы лежит комбинация трех паттернов: **Стратегия** , **Фабричная функция** и **Адаптер** .

### 2.1. Паттерн "Стратегия" (Strategy Pattern)

Это главный архитектурный паттерн, организующий работу с поставщиками. Он позволяет выбирать алгоритм (стратегию) во время выполнения.

- **Контекст (Context):** Наш универсальный обработчик `universalSupplierHandler.ts` является контекстом. Он знает, что нужно выполнить задачу "поиск товара", но не знает, _как именно_ это сделать для конкретного поставщика.
- **Интерфейс Стратегии (Strategy Interface):** Тип `SupplierHandler` в файле `src/types/search.types.ts` определяет общий "контракт", которому должна соответствовать любая стратегия:

  ```
  export type SupplierHandler = (
    data: getItemResultsParams,
    userLogger: Logger
  ) => Promise<SearchResultsParsed[]>;
  ```

  Любая функция, соответствующая этому типу, является валидной стратегией.

- **Конкретные Стратегии (Concrete Strategies):** Каждая запись в объекте `supplierHandlers` (файл `src/sockets/handlers/supplierHandlers.ts`) — это конкретная реализация стратегии для отдельного поставщика.

  ```
  export const supplierHandlers: Record<string, SupplierHandler> = {
    // Стратегия для Profit
    profit: async (data, userLogger) => { /* ... */ },

    // Стратегия для Armtek
    armtek: async (data, userLogger) => { /* ... */ },

    // Стратегия для UG, созданная с помощью фабрики
    ug: createAbcpApiHandler(ugConfig, ['ug']),
    // ... и так далее
  };
  ```

**Как это работает:** `universalSupplierHandler` получает имя поставщика, находит соответствующую ему функцию-стратегию в карте `supplierHandlers` и просто выполняет ее. Это полностью избавляет нас от громоздких `if/else` или `switch` конструкций.

### 2.2. Паттерн "Фабричная функция" (Factory Function)

Вы могли заметить, что стратегии для `ug`, `patriot`, `npn` и `avtodinamika` очень похожи. Чтобы не дублировать их код, мы применили паттерн "Фабрика".

- **Фабрика:** Функция `createAbcpApiHandler` в файле `supplierHandlers.ts` является фабрикой. Ее задача — "производить" стандартные функции-стратегии для поставщиков, работающих через ABCP API.
- **Продукт:** Продуктом этой фабрики является функция, полностью соответствующая интерфейсу `SupplierHandler`.

**Как это работает:** Мы вызываем `createAbcpApiHandler`, передавая ей уникальную конфигурацию (например, `patriotConfig`). Фабрика берет эту конфигурацию и генерирует готовую к использованию функцию, внутри которой уже инкапсулирована вся общая логика: вызов `fetchAbcpData`, маппинг `mapAbcpResponse` и стандартизированная обработка ошибок `createAbcpError`.

Это классический пример принципа **DRY (Don't Repeat Yourself)** .

### 2.3. Паттерн "Адаптер" (Adapter Pattern)

Хотя мы не создавали классы-адаптеры, сама суть паттерна реализована функционально. Каждая стратегия в `supplierHandlers` по своей сути является **адаптером** .

Она **адаптирует** уникальный и сложный интерфейс конкретного сервиса (например, многошаговый процесс для `profit` или парсинг HTML для `mikano`) к простому и единому интерфейсу `SupplierHandler`, который ожидает остальная часть системы.

## 3. Жизненный цикл запроса на поиск

1. **Клиент** отправляет событие `GET_ITEM_RESULTS` с данными `{ item, supplier }` через Socket.IO.
2. **`itemResultsHandler.ts`** перехватывает событие. Его единственная задача — вызвать `universalSupplierHandler`.
3. **`universalSupplierHandler.ts`** (Контекст) выполняет основную работу:
   - Находит нужную функцию-**стратегию** в карте `supplierHandlers` по имени `supplier`.
   - Вызывает найденную стратегию.
   - Оборачивает вызов в `try/catch` для централизованной обработки ошибок.
   - Фильтрует и сортирует полученные результаты.
   - Отправляет клиенту стандартизированный ответ (`SUPPLIER_DATA_FETCH_SUCCESS` или `SUPPLIER_DATA_FETCH_ERROR`).
4. **`supplierHandlers.ts`** (Конкретная Стратегия):
   - Выполняется код, специфичный для данного поставщика.
   - Он **адаптирует** вызовы к реальной бизнес-логике, которая находится в `src/services/`.
   - Возвращает результат в унифицированном формате `SearchResultsParsed[]`.
5. **Клиент** получает данные и отображает их.

## 4. Как добавить нового поставщика?

Благодаря примененным паттернам, добавление нового поставщика — простая и безопасная процедура, затрагивающая всего два файла.

**Шаг 1: Написать бизнес-логику**

- В папке `src/services/` создайте новую папку, например, `src/services/new_supplier/`.
- Внутри напишите функции, отвечающие за реальную работу с API этого поставщика (авторизация, запросы, парсинг ответа).

**Шаг 2: Создать и зарегистрировать стратегию**

- Откройте файл `src/sockets/handlers/supplierHandlers.ts`.
- Добавьте в объект `supplierHandlers` новую запись:

  ```
  // ... другие поставщики

  // --- New Supplier ---
  new_supplier: async (data, userLogger) => {
    // 1. Вызовите вашу бизнес-логику из `src/services/new_supplier/`
    const results = await callNewSupplierApiService(data.item, userLogger);

    // 2. Адаптируйте результат к формату SearchResultsParsed[]
    const mappedResults = mapNewSupplierResults(results);

    // 3. Верните результат
    return mappedResults;
  },
  ```

- **ИЛИ** , если ваш новый поставщик работает на ABCP API, просто добавьте новую конфигурацию в `abcp.configs.ts` и вызовите фабрику:

```
  // ...
  new_abcp_supplier: createAbcpApiHandler(newAbcpConfig, ['new_abcp_supplier']),
  // ...
```

**Готово!** Не нужно трогать контроллеры, основной обработчик сокетов или другие части системы. Архитектура сделает всё за вас.
