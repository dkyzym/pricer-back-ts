
# Руководство по системе расчета дат поставки

## Введение: Философия системы

Основная идея этой архитектуры — отделить **ЧТО** мы хотим сделать от **КАК** мы это делаем.

* **ЧТО (Конфигурация):** Правила каждого поставщика. Они описаны в файле `suppliersConfig.declarative.ts` на простом, почти человеческом языке в виде объектов. Это бизнес-логика.
* **КАК (Движок):** Механизм, который умеет "читать" эти правила и выполнять все математические операции с датами. Он находится в файле `deliveryCalculator.ts`.

Вам, как разработчику, в 99% случаев нужно будет работать только с файлом конфигурации. Движок — это "черный ящик", который просто выполняет свою работу.

## Важный принцип: Подготовка данных

В процессе работы мы выяснили важный архитектурный принцип: **Если для поставщика требуется сложный парсинг неструктурированных данных (например, текстовых описаний сроков), лучше всего выполнять этот парсинг на этапе подготовки данных, *****до***** вызова основного движка.**

Наш пример с `npn` идеален:

1. Специальная функция `calculateNpnDeadlineHours` разбирает сложные строки и превращает их в простое, понятное число — количество часов до готовности.
2. Это число записывается в поле `deadline`.
3. Движок расчета получает уже очищенные, структурированные данные и работает с ними, используя простые и надежные стратегии.

Этот подход делает сам движок более универсальным и менее подверженным ошибкам, а всю уникальную и сложную логику инкапсулирует в функции-мапперы для конкретных поставщиков.

## Глубокое погружение: Стратегии расчета

Стратегия — это основной способ описания логики поставщика. Вы выбираете одну из четырех, которая лучше всего подходит под его правила.

### Стратегия 1: `DIRECT_FROM_API`

* **Когда использовать?** Самый простой случай. Используйте, когда API поставщика уже возвращает готовую, финальную дату доставки в одном из полей.
* **Ключевые поля:**
  * `strategy`: Всегда `'DIRECT_FROM_API'`.
  * `sourceField`: Название поля в объекте `result`, из которого нужно взять дату (например, `'deliveryDate'`).
  * `avoidDeliveryWeekdays` (необязательно): Массив дней недели (1-Пн, 7-Вс), на которые не должна выпадать доставка.

### Стратегия 2: `RULE_BASED`

* **Когда использовать?** Для сложной логики, которая зависит от  **конкретного дня недели и времени заказа** . Представляйте ее как цепочку правил "ЕСЛИ заказали в этот промежуток, ТО доставить вот так".
* **Ключевые поля:**
  * `strategy`: Всегда `'RULE_BASED'`.
  * `rules`: Массив объектов-правил. Движок будет проверять их по порядку и остановится на первом, которое сработает.
* **Совет по отладке:** Если вы получаете ошибку `Could not calculate delivery date` для поставщика с этой стратегией, первым делом проверьте, что ваши правила покрывают все 7 дней недели.

### Стратегия 3: `SCHEDULE_BASED`

* **Когда использовать?** Для самого распространенного случая: у поставщика есть **фиксированные дни доставки** и **время отсечки (cutoff)** для заказов.
* **Ключевые поля:**
  * `strategy`: Всегда `'SCHEDULE_BASED'`.
  * `deliveryWeekdays`: Массив дней недели, когда возможна доставка.
  * `allowSameDayDelivery`: `true` или `false`. Если `false`, то доставка будет минимум на следующий день.
  * `readinessCalculation`: Определяет, как посчитать "дату готовности" товара.
    * `type: 'FROM_CUTOFF'`: Простая отсечка по времени.
    * `type: 'PLUS_HOURS_FROM_RESULT'`: Дата готовности = текущее время + `X` часов из поля `sourceField`.
    * `type: 'CONDITIONAL_CUTOFF'`: Гибридная логика, зависящая от значения поля `conditionField`.

### Стратегия 4: `SHIPMENT_SCHEDULE_BASED`

* **Когда использовать?** Для сложных поставщиков, у которых есть разделение на **день отгрузки** со склада и **день доставки** клиенту. **Это стратегия для `npn`.**
* **Ключевые поля:**
  * `strategy`: Всегда `'SHIPMENT_SCHEDULE_BASED'`.
  * `shipmentWeekdays`: Дни, когда происходят отгрузки со склада (например, `[2, 5]` для Вт и Пт).
  * `shipmentCutoffTime`: Время отсечки в день отгрузки.
  * `deliveryDelay`: Время, которое проходит от момента отгрузки до доставки клиенту (например, `{ days: 1 }`).
  * `readinessCalculation`: Определяет, как посчитать "дату готовности товара на складе поставщика".
    * `type: 'PLUS_HOURS_FROM_RESULT'`: **Основной способ.** Используется, когда у вас уже есть готовое число часов до готовности (как в `npn`, где поле `deadline` заранее рассчитывается).
    * `type: 'PARSE_DELIVERY_STRING'`: **Продвинутая возможность.** Указывает движку, что нужно попытаться "прочитать" и "понять" текстовую строку из `sourceField`. Используйте это, только если нет возможности подготовить данные заранее.

## Пошаговый план: Как добавить нового поставщика

1. **Анализ.** Прочитайте требования. Есть ли сложный текст для парсинга? Если да, напишите для него отдельную функцию-маппер (как `calculateNpnDeadlineHours`).
2. **Выбор стратегии.** На основе правил выберите одну из четырех стратегий для описания уже **структурированных** данных.
3. **Откройте `suppliersConfig.declarative.ts`.**
4. **Создайте новый объект.** Скопируйте похожий конфиг или начните с нуля.
5. **Заполните поля.** TypeScript и ваш редактор кода будут подсказывать вам, какие поля обязательны.
6. **Переиспользуйте!** Посмотрите, нет ли уже готовых базовых конфигов (`directFromApiBase`, `ugAndAvtodinamikaBaseConfig`), которые можно использовать.
