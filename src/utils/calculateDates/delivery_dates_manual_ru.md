
# Руководство по системе расчета дат поставки

## Введение: Философия системы

Основная идея этой архитектуры — отделить **ЧТО** мы хотим сделать от **КАК** мы это делаем.

* **ЧТО (Конфигурация):** Правила каждого поставщика. Они описаны в файле `suppliersConfig.declarative.ts` на простом, почти человеческом языке в виде объектов. Это бизнес-логика.
* **КАК (Движок):** Механизм, который умеет "читать" эти правила и выполнять все математические операции с датами. Он находится в файле `deliveryCalculator.ts`.

Вам, как разработчику, в 99% случаев нужно будет работать только с файлом конфигурации. Движок — это "черный ящик", который просто выполняет свою работу.

## Три кита системы

1. **`types/dateTypes.d.ts` — Конституция.**
   * **Что это?** Самый главный файл для понимания системы. Он определяет все возможные "слова" и "конструкции", которые вы можете использовать для описания правил поставщика. Это наш с вами словарь и грамматика.
   * **Когда использовать?** Всегда держите его под рукой, когда создаете или изменяете конфигурацию. TypeScript, опираясь на эти типы, не даст вам совершить ошибку.
2. **`suppliersConfig/suppliersConfig.declarative.ts` — Библиотека правил.**
   * **Что это?** Сердце вашей бизнес-логики. Это массив объектов, где каждый объект — полная и исчерпывающая инструкция по расчету даты для одного поставщика.
   * **Когда использовать?** Это основной файл, который вы будете редактировать при добавлении нового поставщика или изменении правил для старого.
3. **`deliveryCalculator.ts` — Движок.**
   * **Что это?** Исполнительный механизм. Он не знает ничего о "Патриоте" или "NPN". Он просто берет конфигурацию, смотрит на ее `strategy` и запускает соответствующую функцию расчета.
   * **Когда использовать?** Вам не нужно его трогать, если только не появится поставщик с абсолютно новой, уникальной механикой, которой нет среди существующих стратегий.

## Глубокое погружение: Стратегии расчета

Стратегия — это основной способ описания логики поставщика. Вы выбираете одну из четырех, которая лучше всего подходит под его правила.

### Стратегия 1: `DIRECT_FROM_API`

* **Когда использовать?** Самый простой случай. Используйте, когда API поставщика уже возвращает готовую, финальную дату доставки в одном из полей.
* **Ключевые поля:**
  * `strategy`: Всегда `'DIRECT_FROM_API'`.
  * `sourceField`: Название поля в объекте `result`, из которого нужно взять дату (например, `'deliveryDate'`).
  * `avoidDeliveryWeekdays` (необязательно): Массив дней недели (1-Пн, 7-Вс), на которые не должна выпадать доставка. Если дата попадет на такой день, она автоматически сдвинется вперед.

### Стратегия 2: `RULE_BASED`

* **Когда использовать?** Для сложной логики, которая зависит от  **конкретного дня недели и времени заказа** . Представляйте ее как цепочку правил "ЕСЛИ заказали в этот промежуток, ТО доставить вот так".
* **Ключевые поля:**
  * `strategy`: Всегда `'RULE_BASED'`.
  * `rules`: Массив объектов-правил. Движок будет проверять их по порядку и остановится на первом, которое сработает.
* **Структура одного правила (`Rule`):**
  * `ifPlaced`: Описывает условие.
    * `from: { weekday: 1, time: '14:00' }`: Начало временного окна.
    * `to: { weekday: 4, time: '13:59' }`: Конец временного окна.
    * **Важно:** Движок корректно обрабатывает диапазоны, переходящие через воскресенье (например, `from: { weekday: 6 }` (Сб) до `to: { weekday: 1 }` (Пн)).
  * `thenDeliver`: Описывает действие, если условие выполнено.
    * `type: 'ON_NEXT_SPECIFIC_WEEKDAY', weekday: 5`: Найти ближайшую пятницу (weekday: 5).
    * `type: 'AFTER_DAYS', days: 1`: Просто прибавить 1 день к дате заказа.
* **Совет по отладке:** Если вы получаете ошибку `Could not calculate delivery date` для поставщика с этой стратегией,  **первым делом проверьте, что ваши правила покрывают все 7 дней недели** . Как мы выяснили на примере `autoImpulse`, если наступает день, для которого нет ни одного правила, движок не сможет рассчитать дату. Всегда добавляйте "правила по умолчанию" в конец списка для всех оставшихся дней.

### Стратегия 3: `SCHEDULE_BASED`

* **Когда использовать?** Для самого распространенного случая: у поставщика есть **фиксированные дни доставки** и **время отсечки (cutoff)** для заказов. Логика всегда такая: 1) Определить, когда товар "готов". 2) Найти следующий доступный день доставки после даты готовности.
* **Ключевые поля:**
  * `strategy`: Всегда `'SCHEDULE_BASED'`.
  * `deliveryWeekdays`: Массив дней недели, когда возможна доставка (например, `[1, 4]` для Пн и Чт).
  * `allowSameDayDelivery`: `true` или `false`. Если `false`, то доставка будет минимум на следующий день, даже если сегодня — день доставки.
  * `readinessCalculation`: Самая важная часть. Определяет, как посчитать "дату готовности" товара.
    * `type: 'FROM_CUTOFF'`: Простая отсечка.
    * `type: 'PLUS_HOURS_FROM_RESULT'`: Дата готовности = текущее время + `X` часов из поля `sourceField` в данных от API.
    * `type: 'CONDITIONAL_CUTOFF'`: Гибридная логика. Проверяет значение поля `conditionField`. Если оно > 0, используется логика `PLUS_HOURS_FROM_RESULT`. Если нет — логика `FROM_CUTOFF`.

### Стратегия 4: `SHIPMENT_SCHEDULE_BASED`

* **Когда использовать?** Для самых сложных поставщиков, у которых есть разделение на **день отгрузки** со склада и **день доставки** клиенту.
* **Ключевые поля:**
  * `strategy`: Всегда `'SHIPMENT_SCHEDULE_BASED'`.
  * `readinessCalculation`: Как и в прошлой стратегии, определяет, когда товар готов к рассмотрению на отгрузку.
  * `shipmentWeekdays`: Дни, когда происходят отгрузки со склада (например, `[2, 5]` для Вт и Пт).
  * `shipmentCutoffTime`: Время отсечки в день отгрузки.
  * `deliveryDelay`: Время, которое проходит от момента отгрузки до доставки клиенту (например, `{ days: 1 }`).

## Пошаговый план: Как добавить нового поставщика

1. **Анализ.** Прочитайте требования или старый код. Ответьте на ключевые вопросы, чтобы выбрать одну из четырех стратегий.
2. **Выбор стратегии.** На основе ответов выберите одну из четырех стратегий.
3. **Откройте `suppliersConfig.declarative.ts`.**
4. **Создайте новый объект.** Скопируйте похожий конфиг или начните с нуля.
5. **Заполните поля.** TypeScript и ваш редактор кода, опираясь на `types/dateTypes.d.ts`, будут подсказывать вам, какие поля обязательны для этой стратегии.
6. **Переиспользуйте!** Посмотрите, нет ли уже готовых базовых конфигов (`directFromApiBase`, `ugAndAvtodinamikaBaseConfig`), которые можно использовать.
